<!DOCTYPE html>
<html lang="en" class=" js cssanimations csstransforms csstransforms3d csstransitions">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Design Patterns in Javascript v.ES6</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Design Patterns in Javascript v.ES6">
    <meta name="keywords"
          content="css3, transitions, animations, css-only, navigation, smooth scrolling, full width, full height, window width, window height">
    <meta name="author" content="Codrops">
    <link rel="stylesheet" type="text/css" href="./statics/demo.css">
    <link rel="stylesheet" type="text/css" href="./statics/style.css">
    <script type="text/javascript" async="" src="./statics/modernizr.custom.79639.js"></script>
</head>
<body>
<div class="container">
    <div class="st-container">
        <input type="radio" name="radio-set" id="st-control-0" checked="checked">
        <a href="#st-panel-0">展示</a>
        <input type="radio" name="radio-set" id="st-control-1">
        <a href="#st-panel-1">适配器模式</a>
        <input type="radio" name="radio-set" id="st-control-2">
        <a href="#st-panel-2">链式模式</a>
        <input type="radio" name="radio-set" id="st-control-3">
        <a href="#st-panel-3">命令模式</a>
        <input type="radio" name="radio-set" id="st-control-4">
        <a href="#st-panel-4">组合模式</a>
        <input type="radio" name="radio-set" id="st-control-5">
        <a href="#st-panel-5">组合迭代模式</a>
        <input type="radio" name="radio-set" id="st-control-6">
        <a href="#st-panel-6">复合模式</a>
        <input type="radio" name="radio-set" id="st-control-7">
        <a href="#st-panel-7">装饰器模式</a>
        <input type="radio" name="radio-set" id="st-control-8">
        <a href="#st-panel-8">外观模式</a>
        <input type="radio" name="radio-set" id="st-control-9">
        <a href="#st-panel-9">工厂模式</a>
        <input type="radio" name="radio-set" id="st-control-10">
        <a href="#st-panel-10">迭代器模式</a>
        <input type="radio" name="radio-set" id="st-control-11">
        <a href="#st-panel-11">懒加载模式</a>
        <input type="radio" name="radio-set" id="st-control-12">
        <a href="#st-panel-12">模块模式</a>
        <input type="radio" name="radio-set" id="st-control-13">
        <a href="#st-panel-13">模块控制模式</a>
        <input type="radio" name="radio-set" id="st-control-14">
        <a href="#st-panel-14">多继承模式 ES6</a>
        <input type="radio" name="radio-set" id="st-control-15">
        <a href="#st-panel-15">MVC模式</a>
        <input type="radio" name="radio-set" id="st-control-16">
        <a href="#st-panel-16">命名空间模式</a>
        <input type="radio" name="radio-set" id="st-control-17">
        <a href="#st-panel-17">空对象模式</a>
        <input type="radio" name="radio-set" id="st-control-18">
        <a href="#st-panel-18">观察者模式</a>
        <input type="radio" name="radio-set" id="st-control-19">
        <a href="#st-panel-19">代理模式</a>
        <input type="radio" name="radio-set" id="st-control-20">
        <a href="#st-panel-20">单例模式</a>
        <input type="radio" name="radio-set" id="st-control-21">
        <a href="#st-panel-21">状态模式</a>
        <input type="radio" name="radio-set" id="st-control-22">
        <a href="#st-panel-22">策略模式</a>
        <input type="radio" name="radio-set" id="st-control-23">
        <a href="#st-panel-23">模板方法模式</a>
        <input type="radio" name="radio-set" id="st-control-24">
        <a href="#st-panel-24">Try-Finally模式</a>
        <div class="st-scroll">
            <section class="st-panel" id="st-panel-0">
                <div class="st-deco" data-icon="a"></div>
                <h2>Javascript设计模式 - ES2015</h2>
                <p>
                    软件设计模式是一套通用的工程解决方案
                </p>
            </section>
            <section class="st-panel" id="st-panel-1">
                <div class="st-deco" data-icon="G"></div>
                <h2>适配器模式</h2>
                <p>
                    将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。
                    <br/>
                    <br/>
                    <a href="Adapter/index.html">实例</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-2">
                <div class="st-deco" data-icon="È"></div>
                <h2>链式模式</h2>
                <p>
                    链式模式作用于链式方法. 如果你不使用链接方式，你需要重复去调用。想像下jQuery的链式调用。
                    <br/>
                    <br/>
                    <a href="Chaining/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-3">
                <div class="st-deco" data-icon="b"></div>
                <h2>Command</h2>
                <p>
                    The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.
                    <br/>
                    <br/>
                    <a href="Command/1/index.html">Example 1</a>
                    <br/>
                    <a href="Command/2/index.html">Example 2</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-4">
                <div class="st-deco" data-icon="V"></div>
                <h2>Composite</h2>
                <p>
                    The Composite Pattern compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.
                    <br/>
                    <br/>
                    <a href="Composite/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-5">
                <div class="st-deco" data-icon="V0"></div>
                <h2>Composite Iterator</h2>
                <p>
                    The Composite Pattern compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.
                    <br/>
                    <br/>
                    <a href="CompositeIterator/1/index.html">Example 1</a>
                    <br/>
                    <a href="CompositeIterator/2/index.html">Example 2</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-6">
                <div class="st-deco" data-icon="K"></div>
                <h2>Compound</h2>
                <p>
                    The Compound Pattern combines at least two patterns into a solution that solves a recurring or general problem.
                    <br/>
                    <br/>
                    <a href="Compound/1/index.html">Example 1</a>
                    <br/>
                    <a href="Compound/2/index.html">Example 2</a>
                    <br/>
                    <a href="Compound/3/index.html">Example 3</a>
                    <br/>
                    <a href="Compound/4/index.html">Example 4</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-7">
                <div class="st-deco" data-icon="H"></div>
                <h2>Decorator</h2>
                <p>
                    The Decorator Pattern attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.
                    <br/>
                    <br/>
                    <a href="Decorator/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-8">
                <div class="st-deco" data-icon="B"></div>
                <h2>Facade</h2>
                <p>
                    The Facade Pattern provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.
                    <br/>
                    <br/>
                    <a href="Facade/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-9">
                <div class="st-deco" data-icon="J"></div>
                <h2>Factory</h2>
                <p>
                    <b>Abstract Factory:</b>
                    <br/>
                    The Abstract Factory Pattern provides an interface for creating families of related of dependent objects without specifying their concrete class.
                    <br/>
                    <b>Factory Method:</b>
                    <br/>
                    The Factory Method Pattern defines an interface for creating an object, but lets subclasses decide which class to instanciate. Factory Method lets a class defer instanciation to subclasses.
                    <br/>
                    <br/>
                    <a href="Factory/1/index.html">Example 1</a>
                    <br/>
                    <a href="Factory/2/index.html">Example 2</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-10">
                <div class="st-deco" data-icon="0"></div>
                <h2>Iterator</h2>
                <p>
                    The Iterator Pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
                    <br/>
                    <br/>
                    <a href="Iterator/1/index.html">Example 1</a>
                    <br/>
                    <a href="Iterator/2/index.html">Example 2</a>
                    <br/>
                    <a href="Iterator/3/index.html">Example 3</a>
                    <br/>
                    <a href="Iterator/4/index.html">Example 4</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-11">
                <div class="st-deco" data-icon="j"></div>
                <h2>Lazy</h2>
                <p>
                    The Lazy Pattern is specially useful when the first time we call a function/method it makes a big job but we only need one part of this job to be done when the function/method is called again. This pattern avoids to repeat job and make faster the execution of code.
                    <br/>
                    <br/>
                    <a href="Lazy/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-12">
                <div class="st-deco" data-icon="Ø"></div>
                <h2>Module</h2>
                <p>
                    The Module Pattern is a way when it's needed to separate functionalities and/or avoid the other modules fail if something goes wrong in one of the other modules.
                    <br/>
                    <br/>
                    <a href="Module/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-13">
                <div class="st-deco" data-icon="Øi"></div>
                <h2>Module Revealed</h2>
                <p>
                    Use the same Module Pattern but uses it to create some private variables/method and only expose the methods that we want to be public. It's used on API's.
                    <br/>
                    <br/>
                    <a href="Module Revealed/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-14">
                <div class="st-deco" data-icon=","></div>
                <h2>Multi-Inheritance ES6</h2>
                <p>
                    This design pattern shows how to implement multi-inheritance using classes in ES6.
                    <br/>
                    <br/>
                    <a href="Multi-Inheritance-ES6/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-15">
                <div class="st-deco" data-icon="Ô"></div>
                <h2>MVC</h2>
                <p>
                    The M.V.C. (Model-View-Controller) Pattern in Javascript is a bit weird, because the view is the element of the DOM, but we can use this method to separated logic and ajax calls in:
                    <br/>
                    <span style="display: block; width: 100%; text-align:left;">- <b>View:</b> DOM element/s.</span>
                    <span style="display: block; width: 100%; text-align:left;">- <b>Model:</b> Class that manages all the access to the server.</span>
                    <span style="display: block; width: 100%; text-align:left;">- <b>Controller:</b> All the logic that will act when the View is updated or when something is returned from Model.</span>
                    <br/>
                    <br/>
                    <a href="MVC/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-16">
                <div class="st-deco" data-icon=";"></div>
                <h2>Namespace</h2>
                <p>
                    The Namespace Pattern is one of the most valuable patterns to be used in Javascript. The Namespace Pattern avoids to pollute globals and allows you to use the same name of method under different Namespaces, and avoids collision with other libraries.
                    <br/>
                    <br/>
                    <a href="Namespace/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-17">
                <div class="st-deco" data-icon="Ë"></div>
                <h2>Nullify</h2>
                <p>
                    The Nullify Pattern is used to remove all references to local variables to make easier the job of the Garbage Collector. This is needed to avoid memory leaks and to manage memory properly.
                    <br/>
                    <br/>
                    <a href="Nullify/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-18">
                <div class="st-deco" data-icon="i"></div>
                <h2>Observer</h2>
                <p>
                    The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
                    <br/>
                    <br/>
                    <a href="Observer/index.html">Example</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-19">
                <div class="st-deco" data-icon="7+"></div>
                <h2>Proxy</h2>
                <p>
                    The Proxy Pattern provide a surrogate or placeholder for another object to control access to it.
                    <br/>
                    <br/>
                    <a href="Proxy/1/index.html">Example</a>
                    <br/>
                    <a href="Proxy/2/index.html">Example Virtual Proxy.</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-20">
                <div class="st-deco" data-icon="L"></div>
                <h2>Singleton</h2>
                <p>
                    The Singleton Pattern ensures a class has only one instance, and provides a global point of access to it.
                    <br/>
                    <br/>
                    <a href="Singleton/1/index.html">Example 1</a>
                    <br/>
                    <a href="Singleton/2/index.html">Example 2</a>
                    <br/>
                    <a href="Singleton/3/index.html">Example 3</a>
                    <br/>
                    <a href="Singleton/4/index.html">Example 4</a>
                </p>
            </section>
            <section class="st-panel" id="st-panel-21">
                <div class="st-deco" data-icon='"'></div>
                <h2>State</h2>
                <p>
                    The State Pattern allow an object to alter its behavior when its internal state changes. The object will appear to change its class.
                    <br/>
                    <br/>
                    <a href="State/1/index.html">Example 1</a>
                    <br/>
                    <a href="State/2/index.html">Example 2</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-22">
                <div class="st-deco" data-icon="_"></div>
                <h2>Strategy</h2>
                <p>
                    The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
                    <br/>
                    <br/>
                    <a href="Strategy/1/index.html">Step 1</a>
                    <br/>
                    <a href="Strategy/2/index.html">Step 2</a>
                    <br/>
                    <a href="Strategy/2_1/index.html">Step 2.1</a>
                    <br/>
                    <a href="Strategy/3/index.html">Step 3</a>
                    <br/>
                    <a href="Strategy/4/index.html">Step 4</a<br/>
                </p>
            </section>
            <section class="st-panel" id="st-panel-23">
                <div class="st-deco" data-icon="E"></div>
                <h2>Template</h2>
                <p>
                    The Template Method Pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.
                    <br/>
                    <br/>
                    <a href="Template/1/index.html">Example with hook</a>
                    <br/>
                    <a href="Template/2/index.html">Example without hook</a>
                </p>
            </section>
            <section class="st-panel st-color" id="st-panel-24">
                <div class="st-deco" data-icon="*"></div>
                <h2>Try-Finally</h2>
                <p>
                    The Try-Finally Pattern is the same as the Nullify Pattern but if you try to use Nullify Pattern in functions/method where you return something Nullify Pattern is not possible because you can lost references.
                    <br/>
                    <br/>
                    <a href="Try-Finally/index.html">Example</a>
                </p>
            </section>
        </div>
    </div>
</div>
</body>
</html>
